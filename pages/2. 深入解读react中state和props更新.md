**React Fiber内部概要**

为了理解这篇文章中所描述的更新过程的技术细节，在我的上一篇文章[《Inside Fiber: 深入解析React中的新协调算法》](https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e)打下夯实基础。

在上篇文章中，我概述了这篇文章中将提及到的主要数据结构和概念，尤其是`fiber节点`, `current tree` 和 `work-in-progress tree`, `副作用`和`副作用列表`.我还高度概括了主要算法，解释了`render`和`commit`阶段的不同点。如果你还没有阅读那篇文章，我建议你先阅读了解一下。

我还向你演示了一个拥有按钮的简单应用——增加数字然后渲染在屏幕上：

![](https://res.cloudinary.com/indepth-dev/image/upload/f_auto,fl_lossy,q_auto/local_media/2019/08/tmp4.mp4)

你可以在[这里](https://stackblitz.com/edit/react-jwqn64)演示上述应用，它由`render`方法返回的两个子元素（`button`和`span`）构成，组件的state由内部句柄更新。这导致了`span`元素的文字更新。

```javascript
class ClickCounter extends React.Component {
    constructor(props) {
        super(props);
        this.state = {count: 0};
        this.handleClick = this.handleClick.bind(this);
    }

    handleClick() {
        this.setState((state) => {
            return {count: state.count + 1};
        });
    }
    
    componentDidUpdate() {}

    render() {
        return [
            <button key="1" onClick={this.handleClick}>Update counter</button>,
            <span key="2">{this.state.count}</span>
        ]
    }
}
```

我还在组件中添加了`componentDidUpdate`生命周期方法。这个用来演示React在`commit`阶段是如何添加[副作用](https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e)并调用这个方法的。

在这篇文章我想向你展示React如何处理state更新并创建副作用列表。我将探索`render`和`commit`阶段的高阶函数中发生了什么。

特别是在React [completeWork](https://github.com/facebook/react/blob/cbbc2b6c4d0d8519145560bd8183ecde55168b12/packages/react-reconciler/src/ReactFiberCompleteWork.js#L532) 函数中如何工作：
- 更新`ClickCounter`组件`state`的`count`属性
- 调用`render`方法来得到子组件列表并进行比较
- 更新`span`元素的 _props_

在React [commitRoot](https://github.com/facebook/react/blob/95a313ec0b957f71798a69d8e83408f40e76765b/packages/react-reconciler/src/ReactFiberScheduler.js#L523)中：
- 更新`span`元素的`textContent`属性
- 调用`componentDidUpdate`生命周期函数

首先，让我们快速浏览一下当在点击事件中调用`setState`，work是如何调度的。

**注意在使用react的过程中你无需知道这些事情。这篇文章是关于React内部如何工作的介绍。**

##调度更新
当我们点击按钮时，`click`事件被触发，React执行我们通过button props传递的回调函数。在我们的应用中，就是简单的增加counter，更新state：

```javascript
class ClickCounter extends React.Component {
    ...
    handleClick() {
        this.setState((state) => {
            return {count: state.count + 1};
        });
    }
}
```

每一个React组件都有一个在组件和React core中间扮演桥的关联`updater`。这允许`setState`可以被ReactDOM, React Native,ssr和单元测试以不同的方式实现.

这篇文章我们将探讨ReactDOM中更新对象的实现，这个实现使用了Fiber协调机制。`ClickCounter`组件是一个[classComponentUpdater](https://github.com/facebook/react/blob/6938dcaacbffb901df27782b7821836961a5b68d/packages/react-reconciler/src/ReactFiberClassComponent.js#L186)。它负责Fiber实例取回、队列更新和工作调度

当更新在排队时，他们只是被添加到更新队列中来处理Fiber节点。在我们当案例中，ClickCounter衍生的`Fiber节点`有如下结构：
```javascript
{
    stateNode: new ClickCounter,
    type: ClickCounter,
    updateQueue: {
         baseState: {count: 0}
         firstUpdate: {
             next: {
                 payload: (state) => { return {count: state.count + 1} }
             }
         },
         ...
     },
     ...
}
```
如你所见， `updateQueue.firstUpdate.next.payload`中的函数就是我们在`ClickCounter`组件中传递给`setState`的回调。它代表了在`render`阶段首先需要被处理的更新。

## 为ClickCounter Fiber节点处理更新
在上一篇文章中的[工作循环章节](https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e)，解释了`nextUnitOfWork`全局变量的角色。尤其是在文章中陈述了这个变量持有`workInProgress`中的Fiber节点的引用，该节点有一些需要处理的工作。在React遍历Fiber树时，它使用这个变量来看是否有其他未完成处理的Fiber节点。


Let’s start with the assumption that the setState method has been called. React adds the callback from setState to the updateQueue on the ClickCounter fiber node and and schedules work. React enters the render phase. It starts traversing from the topmost HostRoot Fiber node using the renderRoot function. However, it bails out of (skips) the already processed Fiber nodes until it finds a node with unfinished work. At this point there’s only one Fiber node with some work to do. It’s the ClickCounter Fiber node.